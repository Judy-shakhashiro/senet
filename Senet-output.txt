====================================================================================================
PROJECT EXPORT FOR LLMs
====================================================================================================

PROJECT INFORMATION:
--------------------------------------------------
Project Name: senet
Generated On: 2026-01-15 22:00:42 (Asia/Damascus / GMT+03:00)
Total Files Processed: 19
Export Tool: Easy Whole Project to Single Text File for LLMs v1.1.0
Tool Author: Jota / Jos√© Guilherme Pandolfi

EXPORT CONFIGURATION:
--------------------------------------------------
Language: en
Max File Size: 1 MB
Include Hidden Files: false
Output Format: both
Notification Level: minimal
Custom File Name Pattern: {workspaceName}-output

================================================================================
PROJECT STRUCTURE
================================================================================
‚îú‚îÄ‚îÄ üìÅ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ GameController.cpython-313.pyc (1.8 KB)
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ GameController.cpython-314.pyc (1.67 KB)
‚îú‚îÄ‚îÄ üìÅ AI/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ __pycache__/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ AIPlayer.cpython-313.pyc (4.76 KB)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ AIPlayer.cpython-314.pyc (2.32 KB)
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ AIPlayer.py (3.57 KB)
‚îú‚îÄ‚îÄ üìÅ GameEngine/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ __pycache__/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Chance.cpython-313.pyc (1.54 KB)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Chance.cpython-314.pyc (1.2 KB)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Player.cpython-313.pyc (1.39 KB)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Player.cpython-314.pyc (1.5 KB)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ State.cpython-313.pyc (14.89 KB)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ State.cpython-314.pyc (11.72 KB)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Chance.py (892 B)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Player.py (482 B)
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ State.py (11.39 KB)
‚îú‚îÄ‚îÄ üìÅ UI/
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ render.py
‚îú‚îÄ‚îÄ üìÑ board.py (1.05 KB)
‚îú‚îÄ‚îÄ üìÑ GameController.py (948 B)
‚îú‚îÄ‚îÄ üìÑ main.py (626 B)
‚îî‚îÄ‚îÄ üìÑ state.py (1.86 KB)

================================================================================
PROJECT STATISTICS
================================================================================
Total Files: 19
Total Directories: 6
Text Files: 9
Binary Files: 10
Total Size: 63.53 KB

FILE TYPES DISTRIBUTION:
------------------------------
.pyc            : 10
.py             : 9

================================================================================
FILE CODE CONTENTS
================================================================================


================================================================================
BINARY/EXCLUDED FILES (not included in text content)
================================================================================
- __pycache__/GameController.cpython-313.pyc
- __pycache__/GameController.cpython-314.pyc


================================================================================
BINARY/EXCLUDED FILES (not included in text content)
================================================================================
- AI/__pycache__/AIPlayer.cpython-313.pyc
- AI/__pycache__/AIPlayer.cpython-314.pyc


================================================================================
FILE: AI/AIPlayer.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 3.57 KB
Extension: .py
Language: python
Location: AI/AIPlayer.py
Relative Path: AI
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 21:55:50 (Asia/Damascus / GMT+03:00)
MD5: 7f7934cba4fecc1f2ddb79d84d0a4965
SHA256: 37540646ddb2e63fb8124167274f806bb66d9731da3b2bec5b3eece19650a857
Encoding: ASCII

FILE CONTENT:
----------------------------------------
from GameEngine.Chance import Chance
from GameEngine.Player import Player
from GameEngine.State import State
import math

class AIPlayer(Player):
    def __init__(self, chance_model : Chance  ,max_depth: int=3):
        self.max_depth = max_depth
        self.chance_model= chance_model
        
    def pass_turn(self, state: State) :
        child = state.copy()
        if child.current_player == 0:
            child.current_player = 1
        else:
            child.current_player = 0
        child.turnCount += 1
        return child
    
    def expectiminimax(self, state: State, depth: int):
        if depth == 0 or state.is_end():
            return self.evaluate(state)
        
        expected_value=0.0
        for options,weights in self.chance_model.outcomes():
                if state.current_player == 1:
                    v = self.max_node_after_throw(state, options, depth)
                else:
                    v = self.min_node_after_throw(state, options, depth)
                expected_value += weights * v
        return expected_value
    

    # MAX decision after throw
    def max_node_after_throw(self, state: State, options: int, depth: int):
        copy_state=state.copy()
        copy_state.rolled_value=options
        moves = copy_state.legal_moves()
        if not moves:
            child = self.pass_turn(copy_state)
            return self.expectiminimax(child, depth - 1)
        best_value = -math.inf
        for move in moves:
            child = copy_state.copy()
            child.move_piece(move) 
            value = self.expectiminimax(child, depth - 1)
            best_value = max(best_value, value)

        return best_value

    # MIN decision after throw
    def min_node_after_throw(self, state: State, options: int, depth: int):
        copy_state=state.copy()
        copy_state.rolled_value=options
        moves = copy_state.legal_moves()
        if not moves:
            child = self.pass_turn(copy_state)
            return self.expectiminimax(child, depth - 1)
        best_value = math.inf
        for move in moves:
            child = copy_state.copy()
            child.move_piece(move)
            value = self.expectiminimax(child, depth - 1)
            best_value = min(best_value, value)

        return best_value

    def choose_move(self, state: State, options: int):
        copy_state=state.copy()
        copy_state.rolled_value=options
        moves = copy_state.legal_moves()
        if not moves:
            return None

        if state.current_player == 1:  
            best_value = -math.inf
            best_move = None
            for move in moves:
                child = copy_state.copy()
                child.move_piece(move)
                v = self.expectiminimax(child, self.max_depth - 1)
                if v > best_value:
                    best_value = v
                    best_move = move
            return best_move

        else:  
            best_value = math.inf
            best_move = None
            for move in moves:
                child = copy_state.copy()
                child.move_piece(move)
                v = self.expectiminimax(child, self.max_depth - 1)
                if v < best_value:
                    best_value = v
                    best_move = move
            return best_move


    def evaluate(self, state: State) -> float:
        winner = state.winner_player
        if winner == "white":
            return 10000
        if winner == "black":
            return -10000
        return 0.0
    

================================================================================


================================================================================
BINARY/EXCLUDED FILES (not included in text content)
================================================================================
- GameEngine/__pycache__/Chance.cpython-313.pyc
- GameEngine/__pycache__/Chance.cpython-314.pyc
- GameEngine/__pycache__/Player.cpython-313.pyc
- GameEngine/__pycache__/Player.cpython-314.pyc
- GameEngine/__pycache__/State.cpython-313.pyc
- GameEngine/__pycache__/State.cpython-314.pyc


================================================================================
FILE: GameEngine/Chance.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 892 B
Extension: .py
Language: python
Location: GameEngine/Chance.py
Relative Path: GameEngine
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 21:53:11 (Asia/Damascus / GMT+03:00)
MD5: 3324aae8586e05b4db12eed8bd423214
SHA256: 2ace7a96789ce6106c3a9ca30e002e6b3baf35a729083751d226a5f8fe4e50a2
Encoding: UTF-8

FILE CONTENT:
----------------------------------------
import numpy as np 
from typing import List, Tuple
class Chance:
    def possible_rolls(self):
        """ÿ™ÿ±ÿ¨ÿπ ŸÇÿßÿ¶ŸÖÿ© ÿ®ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸäŸÖ ÿßŸÑŸÖŸÖŸÉŸÜÿ© ŸÑÿ±ŸÖŸä ÿßŸÑÿπÿµŸä ŸÖÿπ ÿßÿ≠ÿ™ŸÖÿßŸÑÿßÿ™Ÿáÿß"""
        return {1: 4/16, 2: 6/16, 3: 4/16, 4: 1/16, 5: 1/16}


    def roll_table(self):
        rolls = self.possible_rolls()
        options = list(rolls.keys())
        weights = list(rolls.values())
        result = np.random.choice(options, p=weights)
        return  result

    def outcomes(self):
        rolls = self.possible_rolls()
        return list(rolls.items())

    # def apply_roll(self, state, roll):
    #     """ÿ™ÿ∑ÿ®ŸäŸÇ ŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑÿ±ŸÖŸäÿ© ÿπŸÑŸâ ÿßŸÑÿ≠ÿßŸÑÿ© ‚Üí ÿ™ÿ±ÿ¨ÿπ ÿ≠ÿßŸÑÿ© ÿ¨ÿØŸäÿØÿ©"""
    #     # if state has player in house of horus and roll is not 1 then
    #     # move it to rebirth
    #     #
    #     pass

================================================================================


================================================================================
FILE: GameEngine/Player.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 482 B
Extension: .py
Language: python
Location: GameEngine/Player.py
Relative Path: GameEngine
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 16:25:04 (Asia/Damascus / GMT+03:00)
MD5: 5d5f96df72c917bb2721aca163e983d6
SHA256: 9665601c1f3fde7ff26f677cad7691b868a304fac151b65dcd4afc9df8fca315
Encoding: UTF-8

FILE CONTENT:
----------------------------------------
from GameEngine.State import State
class Player:
    def policy(self, state: State):
        """ÿ™ÿ≠ÿØÿØ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ™Ÿä ÿ≥ŸäŸÜŸÅÿ∞Ÿáÿß ÿßŸÑŸÑÿßÿπÿ® ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿ≠ÿßŸÑÿ™Ÿá"""
        pass

class HumanPlayer(Player):
    def policy(self, state):
        """ÿ•ÿØÿÆÿßŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ"""
        pass

class RandomPlayer(Player):
    def policy(self, state):
        """ÿßÿÆÿ™Ÿäÿßÿ± ÿπÿ¥Ÿàÿßÿ¶Ÿä ŸÖŸÜ ÿßŸÑÿ≠ÿ±ŸÉÿßÿ™ ÿßŸÑŸÇÿßŸÜŸàŸÜŸäÿ©"""
        pass

================================================================================


================================================================================
FILE: GameEngine/State.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 11.39 KB
Extension: .py
Language: python
Location: GameEngine/State.py
Relative Path: GameEngine
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 22:00:42 (Asia/Damascus / GMT+03:00)
MD5: 196f28415e1c3121b9e8008470eeabac
SHA256: 2eea8d3cb5642a47543880105e6dc2ed4e7dc2d5a8b20840a657bc7a19582732
Encoding: ASCII

FILE CONTENT:
----------------------------------------
from typing import Optional
from colorama import Fore, Back, Style
import copy
from GameEngine.Chance import Chance
class Cell:
    def __init__(self,t,p):
        types=['O','B','W','H','T','R','S']
        players=[0,1,None]
        if t in types:
            self.type=t
        if p in players:
            self.player=p
class State:
    def __init__(self,turnCount:int=0,last_hit = None):
        self.cells=self.initialize_board()
        self.white_pieces=0
        self.black_pieces=0
        self.current_player=1  
        self.winner_player=None
        self.game_over=False
        self.rolled_value=None
        self.turnCount = turnCount
        self.last_hit = last_hit
    
    def display(self):
        print(Fore.MAGENTA + "-------------------")
        for i in range(10):
            cell=self.cells[i]
            if cell.player==1:
                print(Fore.BLUE + cell.type, end=' ')
            elif cell.player==0:
                print(Fore.MAGENTA + cell.type, end=' ')
            else:
                print(Fore.RESET + cell.type, end=' ')
            if (i+1)%10==0:
                print() 
        for i in range(10,20):
            cell=self.cells[29-i]
            if cell.player==1:
                print(Fore.BLUE + cell.type, end=' ')
            elif cell.player==0:
                print(Fore.MAGENTA + cell.type, end=' ')
            else:
                print(Fore.RESET + cell.type, end=' ')
            if (i+1)%10==0:
                print()  
        for i in range(20,30):
            cell=self.cells[i]
            if cell.player==1:
                print(Fore.BLUE + cell.type, end=' ')
            elif cell.player==0:
                print(Fore.MAGENTA + cell.type, end=' ')
            else:
                print(Fore.RESET + cell.type, end=' ')
            
            if (i+1)%10==0:
                print()  
                    # New line after every 10 cells
        print(Fore.MAGENTA+"-------------------")
            

    def initialize_board(self):
        list=[]
        for i in range(14):
            if(i%2==0):
                list.append(Cell('O', 1))
            else:
                list.append(Cell('O',0))
        list.append(Cell('B',None))
        for i in range(10):
            list.append(Cell('O',None))
        list.append(Cell('H',None))
        list.append(Cell('W',None))
        list.append(Cell('T',None))
        list.append(Cell('R',None))
        list.append(Cell('S',None))
        return list



    def move_piece(self,index):
        self.last_hit=None
        # index is the index of the piece we want to move
        # here piece means the piece we want to move
        # check if there is a player in house of horus and it is different 
        # from the cell we want to move ,then we move it to rebirth
        #    if(cells[29].player is not None and index!=29):
        #         self.to_rebirth()
        
        # if newpiece location is water ,go to rebirth
        if index+self.rolled_value<30 and self.cells[index+self.rolled_value].type == 'W' :
            self.cells[index].player = None
            self.to_rebirth(index+self.rolled_value)
            self.turnCount+=1
            self.current_player ^=1
            return self
            
        # else if toss is 3 and cells[index].type is house of three truths then promote()
        if self.cells[27].player ==self.current_player:
            if self.rolled_value == 3 and index == 27:
                self.promote(index)
                
            else:
                self.cells[27].player = None
                self.to_rebirth(27)
            self.turnCount +=1
            self.current_player ^=1
            return self    
                
        # else if toss is 2 and cells[index].type is house of re-atoum then promote()
        if self.cells[28].player ==self.current_player:
            if self.rolled_value == 2 and index == 28:
                self.promote(index)
                
            else: 
                self.cells[28].player=None
                self.to_rebirth(28)
            self.turnCount +=1
            self.current_player ^=1  
            return self 
                

        # else if it is any toss cells[index].type is house of horus then promote()
        if self.cells[29].player ==self.current_player:
            if index==29:
                self.promote(index)
                self.turnCount += 1
                self.current_player ^= 1
                return self
                
        # if a pawn is in the happiness and we rolled is 5 and player wanna move it
        if self.cells[25].player ==self.current_player:
            if (self.rolled_value==5 and index==25):
                self.promote(index)
                self.turnCount += 1
                self.current_player ^= 1
                return self
        

        # else (alter between black and white or to an empty space) 
        if index+self.rolled_value<30:
                if(self.cells[index+self.rolled_value].player is not None and self.cells[index+self.rolled_value].player != self.current_player):
                    
                    self.cells[index+self.rolled_value].player=self.current_player
                    self.cells[index].player=self.current_player^1
                    self.last_hit=self.current_player
                    
                elif(self.cells[index+self.rolled_value].player is None):
                    self.cells[index+self.rolled_value].player=self.current_player
                    self.cells[index].player=None
                    
                    # print(f'moved to empty cell at index {index+self.rolled_value} of player{self.current_player}')
        # in order to return the state after move 
        # just write this state=state.move_piece(toss,state.cells,index)    
        self.turnCount +=1
        self.current_player ^= 1
        return self
    
    def legal_moves(self):
        # should include the promotions and rebirth
        # return a list of indices of pieces that can be moved
        #  based on rolled_value and current_player
        legal_moves_list=[]
        for i in range(25):
            cell=self.cells[i]
            if cell.player == self.current_player:
                if self.is_valid_move(i):
                    legal_moves_list.append(i)
        return legal_moves_list 

    def is_valid_move(self,index):
        # 1 should not skip house of happiness
        if(index < 25 and index+self.rolled_value>25):
            return False
        if (index==25 and self.rolled_value==5):
            return True
        # 2 should not go beyond the last cell
        if(index>29):
            return False
        # 3 it should be a pawn from the current player pawns
        cell=self.cells[index]
        if(cell.player != self.current_player):
            return False
        # 4 should not land on a cell occupied by the same color
        if(index+self.rolled_value<25 and self.cells[index+self.rolled_value].player == self.current_player):
            return False
        return True

    def promote(self,index):
        self.cells[index].player= None
        if (self.current_player==0):
            self.black_pieces+=1
        else:
            self.white_pieces+=1

    def to_rebirth(self,index):
        # move to rebirth and 
        # if there is a piece on the rebirth 
        # then move to the first empty cell before it
        self.cells[index].player=None
        if(self.cells[14].player is None):
            self.cells[14].player=self.current_player
            return
        else:
            for i in range(14,-1,-1):
                if(self.cells[i].player is None):
                    self.cells[i].player=self.current_player
                    print(f'{index} rebirthed to {i}')
                    return
            
    def play(self):
        while True:
            self.display()
            #check win
            # self.current_player=self.current_player ^ 1
            if(self.white_pieces==7):
                print(Fore.BLUE+'blue won !')
                return
            elif(self.black_pieces==7):
                print(Fore.MAGENTA+'magenta won !')
                return 
            chance=Chance()
            self.rolled_value=chance.roll_table()

            if self.current_player == 1 :
                print(Fore.BLUE+f'valid moves are: {self.legal_moves()}')
                print(Fore.BLUE+f'player blue rolled a {self.rolled_value}')
            else:
                print(Fore.MAGENTA+f'valid moves are: {self.legal_moves()}')
                print(Fore.MAGENTA+f'player magenta rolled a {self.rolled_value}')
            index=self.input()

            # legal_moves=self.legal_moves()
            # if(len(legal_moves)==0):
            #    print('no legal moves available ,turn skipped')
            #    continue
            # elif(index in legal_moves):
            while not self.is_valid_move(index):
                print(Fore.RED+'invalid move ,try again')
        
                index=self.input()
            self.move_piece(index)

    def copy(self):
        #return deep copy of the state
        return copy.deepcopy(self)
    
    def input(self):
        while True:
            index=input(Fore.WHITE+'Enter the index of the piece you want to move: ')
            try: 
                index=int(index)
                break
            except:
                print(Fore.RED+'Invalid move ,try again')
        return index


    def is_end(self) -> bool:
        if self.winner() is not None :
            return True
        return False
    
    def winner(self)->int:
        if self.black_pieces == 7:
            self.winner_player = "black"
            return 0
        if self.white_pieces==7:
            self.winner_player = "white" 
            return 1
        return None  
    
    def play_ai_vs_human(self, ai_player):
        chance = Chance()
        while not self.is_end():
            self.display()
            self.rolled_value = chance.roll_table()
            moves = self.legal_moves()
            if self.current_player == 1:
                print(Fore.BLUE + f"AI (blue) rolled {self.rolled_value}")
                print(Fore.BLUE + f"Valid moves: {moves}")
            else:
                print(Fore.MAGENTA + f"Human (magenta) rolled {self.rolled_value}")
                print(Fore.MAGENTA + f"Valid moves: {moves}")
        
            if not moves:
                print(Fore.YELLOW + "No valid moves ‚Üí turn skipped")
                self.current_player ^= 1
                self.turnCount += 1
                continue

            if self.current_player == 1:
                move = ai_player.choose_move(self, self.rolled_value)
                print(Fore.BLUE + f"AI chooses move: {move}")
                self.move_piece(move)

    
            else:
                move = int(input(Fore.WHITE + "Enter index to move: "))
                while move not in moves:
                    print(Fore.RED + "Invalid move, choose from:", moves)
                    move = int(input(Fore.WHITE + "Enter index to move: "))
                self.move_piece(move)

        winner = self.winner_player
        if winner == "white":
            print(Fore.BLUE + "BLUE (AI) WON ")
        else:
            print(Fore.MAGENTA + "MAGENTA (HUMAN) WON ")

================================================================================


================================================================================
FILE: UI/render.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 0 B
Extension: .py
Language: python
Location: UI/render.py
Relative Path: UI
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
MD5: d41d8cd98f00b204e9800998ecf8427e
SHA256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
Encoding: ASCII

FILE CONTENT:
----------------------------------------

================================================================================


================================================================================
FILE: board.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 1.05 KB
Extension: .py
Language: python
Location: board.py
Relative Path: root
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
MD5: b40b2061898460c4db34b47605554a72
SHA256: e94d3bae92fd68399f6eeee6aba122c5968168d3684646fc0ce87c590a1f4312
Encoding: ASCII

FILE CONTENT:
----------------------------------------
class board:
    def __init__(self):
        self.cells=self.initialize_board()
        self.white_pieces=0
        self.black_pieces=0
        
    def display(self):
        print("Displaying the board")
        # to implement

    def initialize_board():
        list=[]
        for i in range(14):
            if(i%0==0):
             list.append(cell('Empty', 'White'))
            else:
             list.append(cell('Empty','Black'))
        list.append(cell('Rebirth',None))
        for i in range(10):
           list.append(cell('Empty',None))
        list.append('Happiness',None)
        list.append('Water',None)
        list.append('Three_Truths',None)
        list.append('Re_Atoum',None)
        list.append('Horus',None)
        return list


class cell:
    def __init__(self,t,p):
        types=['Empty','Rebirth','Water','Happiness','Three_Truths','Re_Atoum','Horus']
        players=['Black','White',None]
        if t in types:
            self.type=t
        if p in players:
            self.player=p

    
    


================================================================================


================================================================================
FILE: GameController.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 948 B
Extension: .py
Language: python
Location: GameController.py
Relative Path: root
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 16:25:04 (Asia/Damascus / GMT+03:00)
MD5: c97c8e80c46cc73ea6a31e3160e18cfe
SHA256: 9a17f07fbacc45cd9170b1a26a840e4ba051d2593c1ec7d1094916ce9de67aab
Encoding: ASCII

FILE CONTENT:
----------------------------------------
"""
Game Controller
"""
class GameController:
    def __init__(self, state, chance, player_max, player_min, view=None):
        self.state = state

        self.chance = chance
        self.players = {
            "MAX": player_max,
            "MIN": player_min
        }
        # self.view = view

    def game_loop(self):
        while not self.rules.is_end(self.state):
            current_player = self.state.current_player

            # 1. Chance
            roll = self.chance.roll()
            self.state = self.chance.apply_roll(self.state, roll)
            # self.view.show_roll(roll)

            # 2. Decision
            legal_moves = self.rules.legal_moves(self.state)
            move = self.players[current_player].policy(self.state)

            # 3. Transition
            self.state = self.rules.apply_move(self.state, move)

            # 4. Render
            # self.view.render(self.state)

================================================================================


================================================================================
FILE: main.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 626 B
Extension: .py
Language: python
Location: main.py
Relative Path: root
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 21:49:12 (Asia/Damascus / GMT+03:00)
MD5: 31acb140f6ad2497dd19dfa8d05136cb
SHA256: 5ace6e2978fcdd7928d5cfd9c1e09d6e25f4f744e4ff6f27991eb10d0c404803
Encoding: ASCII

FILE CONTENT:
----------------------------------------
"""
This is main file where is an entry point to our project
"""
from GameEngine.State import State

from GameEngine.Chance import Chance
from GameEngine.Player import HumanPlayer
from AI.AIPlayer import AIPlayer
from GameController import GameController

state = State()

chance = Chance()

player_max = AIPlayer(chance_model=chance,max_depth=3)
player_min = HumanPlayer()

# view = GUIView()

game = GameController(
    state=state,
    chance=chance,
    player_max=player_max,
    player_min=player_min,
    # view=view
)

# game.game_loop()
# state.play()
state.play_ai_vs_human(player_max)

================================================================================


================================================================================
FILE: state.py
================================================================================

FILE INFORMATION:
----------------------------------------
Size: 1.86 KB
Extension: .py
Language: python
Location: state.py
Relative Path: root
Created: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
Modified: 2026-01-15 09:27:03 (Asia/Damascus / GMT+03:00)
MD5: e3decceb979a84e34612aae16e2442fd
SHA256: 5e8c369d7dfb53dc059a8b319fb84858f0036e3e462a596941ebf33d49f2ac89
Encoding: ASCII

FILE CONTENT:
----------------------------------------
from board import cell
class state:
    def __init__(self):
      pass

    def play_toss(self):
        # to implement based on the probabilities tabel
        pass
    
    def move_piece(self,toss,cells,index):
       #here piece means the piece we want to move
       # check if there is a player in house of houros and it is different 
       # from the cell we want to move ,then we move it to rebirth
       # if newpiece location is water ,o to rebirth
       # else if toss is 3 and cells[index].t is house of three truths then promote()
       # else if toss is 2 and cells[index].t is house of re-atoum then promote()
       # else if it is ant toss cells[index].t is house of horus then promote()
       # else (alter between black and white)  if cells[index].p=='White' cells[index].p='Black' else cells[index].p='White'

       pass
    def is_valid_move(self,toss,cell,index):
        # 1 should not skip house of happiness
        # 2 should not be a cell of the same color
       
        pass
    def promote(self,board,index,player):
        board.cells[index].p= None
        if (player=='Black'):
            board.black_pieces
        else:    
          board.white_pieces
    def to_rebirth(self):
       # if there is a piece on the house 
       pass
    def play(self,board):
     while True:
        #check win
        if(board.white_pieces==0):
         print('white won !')
         return
        elif(board.white_pieces==1):
            print('black won !')
            return 
        result=self.play_toss()
        # if there is a palyer in three truths and the result is not thre
        #  then 
        # move it to rebirth
        # if there is a player in re-Atoum and the result is not 2 
        #then 
        # move to rebirth


        # else 
        self.move_player()


        



        


================================================================================
